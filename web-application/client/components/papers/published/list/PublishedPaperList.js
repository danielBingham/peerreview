import React, { useState, useEffect, useLayoutEffect, useRef } from 'react'
import { useDispatch, useSelector } from 'react-redux'
import { useSearchParams } from 'react-router-dom'

import isEqual from 'lodash.isequal'

import { DocumentCheckIcon } from '@heroicons/react/24/outline'

import { getPapers, clearPaperQuery, cleanupRequest } from '/state/papers'
import { countResponses, cleanupRequest as cleanupResponseRequest } from '/state/responses'

import Spinner from '/components/Spinner'
import { FloatingMenu, FloatingMenuTrigger, FloatingMenuBody, FloatingMenuItem } from '/components/generic/floating-menu/FloatingMenu'

import { 
    List, 
    ListHeader, 
    ListTitle, 
    ListControls, 
    ListControl, 
    ListRowContent, 
    ListNoContent 
} from '/components/generic/list/List'
import PaginationControls from '/components/PaginationControls'

import PublishedPaperListItem from './PublishedPaperListItem'

import './PublishedPaperList.css'


/**
 * A list displaying the papers that have been posted. 
 *
 * @param {object} props - An empty object, takes no props.
 */
const PublishedPaperList = function(props) { 
    const [ searchParams, setSearchParams ] = useSearchParams()

    // ======= Request Tracking =====================================

    const [requestId, setRequestId ] = useState(null)
    const request = useSelector(function(state) {
        if (requestId) {
            return state.papers.requests[requestId]
        } else {
            null
        }
    })

    const [responseRequestId, setResponseRequestId ] = useState(null)
    const responseRequest = useSelector(function(state) {
        if (responseRequestId) {
            return state.papers.requests[responseRequestId]
        } else {
            null
        }
    })


    // ======= Redux State ==========================================
   
    const paperQuery = useSelector(function(state) {
        return state.papers.queries['PublishedPaperList']
    })

    const counts = useSelector(function(state) {
        return state.papers.counts 
    })

    // ======= Effect Handling ======================================

    const dispatch = useDispatch()

    const setSort = function(sortBy) {
        searchParams.set('sort', sortBy)
        setSearchParams(searchParams)
    }

    const queryForPapers = function({searchString, sortBy, page}) {
        let query = {}
        if ( props.query ) {
            query = {
                ...props.query
            }
        }

        if ( props.fieldId ) {
            if ( query.fields ) {
                query.fields.push(props.fieldId)
            } else {
                query.fields = [ props.fieldId ]
            }
        }

        if ( props.journalId ) {
            query.journalId = props.journalId
        }

        if ( searchString ) {
            query.searchString = searchString
        }

        if ( props.authorId ) {
            query.authorId = props.authorId
        }

        query.isDraft = false

        if ( ! sortBy ) {
            query.sort = 'newest'
        } else {
            query.sort = sortBy
        }

        if ( ! page ) {
            query.page = 1
        } else {
            query.page = page
        }

        setRequestId(dispatch(getPapers('PublishedPaperList', query, true)))
        setResponseRequestId(dispatch(countResponses()))
    }

    useEffect(function() {
        const params = {
            searchString: searchParams.get('q'),
            sortBy: searchParams.get('sort'),
            page: searchParams.get('page')
        }
        queryForPapers(params)
    }, [ searchParams, props.fieldId ])

    useEffect(function() {
        return function cleanup() {
            dispatch(clearPaperQuery({ name: 'PublishedPaperList' }))
        }
    }, [])

    // Cleanup our request.
    useEffect(function() {
        return function cleanup() {
            if ( requestId ) {
                dispatch(cleanupRequest({requestId: requestId}))
            }
        }
    }, [ requestId ])

    // Cleanup our request.
    useEffect(function() {
        return function cleanup() {
            if ( responseRequestId ) {
                dispatch(cleanupResponseRequest({requestId: responseRequestId}))
            }
        }
    }, [ responseRequestId ])

    // ======= Render ===============================================
    
    // Don't render unless we've completed the request, otherwise we could wind
    // up rendering a list generated by a different request.
    
    let content = (<Spinner local={true} /> ) 
    let noContent = null
    if ( request && request.state == 'fulfilled') { 
        content = []
        for (const paper of paperQuery.list) {
            content.push(<PublishedPaperListItem paper={paper} key={paper.id} />)
        }

        if ( content.length == 0 ) {
            content = null
            noContent = ( <div className="empty-search">No published papers to display.</div>)
        }
    }

    if ( request && request.state == 'failed' ) {
        content = null
        noContent = (<div className="error">Something went wrong with our attempt to retreive the paper list: { request.error }.</div>)
    }

    const newestParams = new URLSearchParams(searchParams.toString())
    newestParams.set('sort', 'newest')

    const activeParams = new URLSearchParams(searchParams.toString())
    activeParams.set('sort', 'active')

    const sort = searchParams.get('sort') ? searchParams.get('sort') : 'newest'
    return (
        <List>
            <ListHeader>
                <ListTitle><DocumentCheckIcon/>Papers</ListTitle>
                <ListControls>
                    <ListControl>
                        <FloatingMenu>
                            <FloatingMenuTrigger>Journals</FloatingMenuTrigger>
                            <FloatingMenuBody>
                                <FloatingMenuItem>Under Construction</FloatingMenuItem>
                            </FloatingMenuBody>
                        </FloatingMenu>
                    </ListControl>
                    <ListControl>
                        <FloatingMenu>
                            <FloatingMenuTrigger>Authors</FloatingMenuTrigger>
                            <FloatingMenuBody>
                                <FloatingMenuItem>Under Construction</FloatingMenuItem>
                            </FloatingMenuBody>
                        </FloatingMenu>
                    </ListControl>
                    <ListControl>
                        <FloatingMenu>
                            <FloatingMenuTrigger>Taxonomy</FloatingMenuTrigger>
                            <FloatingMenuBody>
                                <FloatingMenuItem>Under Construction</FloatingMenuItem>
                            </FloatingMenuBody>
                        </FloatingMenu>
                    </ListControl>
                    <ListControl>
                        <FloatingMenu closeOnClick={true}>
                            <FloatingMenuTrigger>Sort: { sort }</FloatingMenuTrigger>
                            <FloatingMenuBody>
                                <FloatingMenuItem><a url={`?${newestParams.toString()}`}
                                    onClick={() => { setSort('newest')}} 
                                >Newest</a></FloatingMenuItem>
                                <FloatingMenuItem><a url={`?${activeParams.toString()}`} 
                                    onClick={() => {  setSort('active')}} 
                                >Active</a></FloatingMenuItem>
                            </FloatingMenuBody>
                        </FloatingMenu>
                    </ListControl>
                </ListControls>
            </ListHeader>
            <ListNoContent>
                {noContent}
            </ListNoContent>
            <ListRowContent>
                {content}
            </ListRowContent>
            <PaginationControls meta={paperQuery?.meta} />
        </List>
    )
}

export default PublishedPaperList 
