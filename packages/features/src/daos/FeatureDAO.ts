/******************************************************************************
 *
 *  JournalHub -- Universal Scholarly Publishing 
 *  Copyright (C) 2022 - 2024 Daniel Bingham 
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

import { QueryResultRow } from 'pg'

import { Core, DAOError } from '@journalhub/core'
import { Feature, FeatureStatus, PartialFeature, FeatureDictionary } from '../types/Feature'


/**
 * Data Access Object for Features: our feature flags.
 *
 * @see `features` table in `database/initialization-scripts/schema.sql`
 * @see `packages/model/src/types/Feature.ts`
 */
export class FeatureDAO {
    core: Core

    /**
     * SQL string.  The selection string used to select the fields of a Feature object.
     */
    selectionString: string

    /**
     * Construct the FeatureDAO from a core.
     */
    constructor(core: Core) {
        this.core = core

        this.selectionString = `
            features.name as Feature_name, features.status as Feature_status, 
            features.created_date as "Feature_createdDate", features.updated_date as "Feature_updatedDate"
        `
    }

    /**
     * Hydrate a single Feature from a QueryResultRow.
     *
     * @param {QueryResultRow} row  The row from the database query to use.
     * Must contain results generated by FeatureDAO.selectionString. Other
     * results will be ignored, so it can be used on rows that contain
     * additional data.
     *
     * @return {Feature}    The populated Feature object.
     */
    hydrateFeature(row: QueryResultRow): Feature {
        return {
            name: row.Feature_name,
            status: row.Feature_status as FeatureStatus,
            createdDate: row.Feature_createdDate,
            updatedDate: row.Feature_updatedDate
        }
    }

    /**
     * Hydrate a DatabaseResult of Features from a QueryResultRow[].
     *
     * @param {QueryResultRow[]} rows   The result rows to translate into
     * Feature objects.  Must contain fields selected by
     * `FeatureDAO.selectionString`. Other fields will be ignored, allowing this
     * to be used on rows that contain additional data.
     *
     * @return {DatabaseResult<Feature>}    A populated DatabaseResult<Feature> object.
     */
    hydrateFeatures(rows: QueryResultRow[]): FeatureDictionary {
        const dictionary: FeatureDictionary = {}

        if ( rows.length <= 0 ) {
            return dictionary 
        }

        for(const row of rows) {
            const feature = this.hydrateFeature(row)

            if ( ! dictionary[feature.name] ) {
                dictionary[feature.name] = feature
            }
        }
        return dictionary 
    }

    /**
     * Select Features from the database using a parameterized `WHERE` statement.
     *
     * @param {string} where    (Optional) The `WHERE` statement of an SQL `SELECT` statement. Must be parameterized for use with `pg`'s `Pool.query`.
     * @param {any[]} params    (Optional) Parameters for the parameterized `WHERE` statement.
     *
     * @return {Promise<DatabaseResult<Feature>>}   A Promise that resolves
     * with a DatabaseResult<Feature> with the results of the query.
     */
    async selectFeatures(where?: string, params?: any[]): Promise<FeatureDictionary> {
        where = where ? where : ''
        params = params ? params : []

        const sql = `
            SELECT
                ${this.selectionString}
            FROM features
            ${where}
        `

        const results = await this.core.database.query(sql, params)

        return this.hydrateFeatures(results.rows)
    }

    /**
     * Insert a row into the `features` table from a Feature.
     * @see `database/initialization-scripts/schema.sql`
     *
     * @param {Feature} feature     The feature to translate to the database
     * and insert.
     *
     * @throws {DAOError}   If something goes awry when inserting.
     *
     * @return {Promise<void>}
     */
    async insertFeature(feature: Feature): Promise<void> {
        const sql = `
            INSERT INTO features (name, status, created_date, updated_date)
                VALUES ($1, $2, now(), now())
        `

        const result = await this.core.database.query(sql, [ feature.name, feature.status ])
        
        if ( ! result.rowCount || result.rowCount <= 0 ) {
            throw new DAOError('insert-failed', `Failed to insert Feature(${feature.name}).`)
        }
    }

    /**
     * Update a row in the `features` table from a PartialFeature.
     * @see `database/initialization-scripts/schema.sql`
     *
     * @param {PartialFeature} feature  The partial feature to use to update
     * the row. Contains only the fields which may be updated through the API,
     * with many fields optional.
     *
     * @return {Promise<void>}
     */
    async updatePartialFeature(feature: PartialFeature): Promise<void> {
        // We'll ignore these fields when assembling the patch SQL.  These are
        // fields that either need more processing (authors) or that we let the
        // database handle (date fields, id, etc)
        const ignoredFields = [ 'name', 'createdDate', 'updatedDate' ]

        let sql = 'UPDATE features SET '
        let params: any[] = []
        let count = 1
        for(let key of Object.keys(feature)) {
            if (ignoredFields.includes(key)) {
                continue
            }

            sql += key + ' = $' + count + ', '

            params.push(feature[key as keyof PartialFeature])
            count = count + 1
        }
        sql += 'updated_date = now() WHERE name = $' + count

        params.push(feature.name)

        const results = await this.core.database.query(sql, params)

        if ( ! results.rowCount || results.rowCount <= 0 ) {
            throw new DAOError('update-failure', `Failed to update Feature(${feature.name}) with partial update.`) 
        }
    }

}
